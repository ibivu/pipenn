import sys

import pandas as pd
import numpy as np

from PPIDataset import DatasetParams, DatasetPreparation

NETSURP_OUTPUT_FILE = DatasetParams.USERDS_INPUT_DIR + "netsurfp_output.csv"
MMSEQS_OUTPUT_FILE = DatasetParams.USERDS_INPUT_DIR + "out.mm_pssm"
TEMP_FILE = DatasetParams.USERDS_INPUT_DIR + "temp.csv"

NETSURFP_COLUMNS = [
    'id',
    'seq',
    #'n',
    'rsa',
    'asa',
    #'q3',
    'p[q3_H]',
    'p[q3_E]',
    'p[q3_C]',
    #'q8',
    #'p[q8_G]',
    #'p[q8_H]',
    #'p[q8_I]',
    #'p[q8_B]',
    #'p[q8_E]',
    #'p[q8_S]',
    #'p[q8_T]',
    #'p[q8_C]',
    #'phi',
    #'psi',
    #'disorder',  
   ]

MMSEQS_PSSM_COLUMNS = [
    'Pos',
    'Cns',
    'A',
    'C',
    'D',
    'E',
    'F',
    'G',
    'H',
    'I',
    'K',
    'L',
    'M',
    'N',
    'P',
    'Q',
    'R',
    'S',
    'T',
    'V',
    'W',
    'Y',
    ]

FINAL_FEATURE_COLUMNS = [
    # Don't change the order.
    #0:7
    'uniprot_id',    
    'sequence',
    'rel_surf_acc',    
    'normalized_abs_surf_acc',
    'prob_helix',
    'prob_sheet',
    'prob_coil',
    
    #7:14
    'length',
    'normalized_length',
    'p_interface',
    's_interface',
    'n_interface',
    'any_interface',
    'domain',
    
    #14:
    'pssm_A','pssm_C','pssm_D','pssm_E','pssm_F','pssm_G','pssm_H','pssm_I','pssm_K','pssm_L',
    'pssm_M','pssm_N','pssm_P','pssm_Q','pssm_R','pssm_S','pssm_T','pssm_V','pssm_W','pssm_Y',
    ]

NORMALIZATION_DATA = {
        #Min and Max values for ASA in the training data set: min=0;max=233;
        FINAL_FEATURE_COLUMNS[3]: [0.0, 233.0],
        #Min and Max values for LENGTH in the training data set: min=26;max=700;
        #FINAL_FEATURE_COLUMNS[8]: [0.0, 700.0],??
        FINAL_FEATURE_COLUMNS[8]: [0.0, 2050.0],
    }
    
def parseNetsurfpOutput():
    """
               id seq       rsa         asa   p[q3_H]   p[q3_E]   p[q3_C]  length
    0    2WNS.A.1   A  0.853317   94.035523  0.010701  0.000832  0.988467   197.0
    1    2WNS.A.1   L  0.342692   62.746881  0.274206  0.010192  0.715602   197.0
    ..        ...  ..       ...         ...       ...       ...       ...     ...
    354    119L.A   W  0.152228   36.610841  0.205163  0.004428  0.790409   162.0
    355    119L.A   D  0.773299  111.432452  0.645500  0.002884  0.351616   162.0
    """
    def normalizeData(df):
        colNames = NORMALIZATION_DATA.keys()
        for colName in colNames:
            try:
                minVal = NORMALIZATION_DATA[colName][0]
                maxVal = NORMALIZATION_DATA[colName][1]
                #print("colName={} min={} and max={}".format(colName, minVal, maxVal))
                df[colName] = (df[colName] - minVal) / (maxVal - minVal)
                df.loc[df[colName]>1.0, colName] = 1.0 
            except KeyError:
                print('WARNING: AA LEN/ASA is out of range of min-max. LEN=[26,700], ASA=[0,233]')
        return df
    
    
    def addNewCols(df_nsp, id_col_name, prot_ids, prot_lens):
        for i in range(7,14):
            df_nsp[FINAL_FEATURE_COLUMNS[i]] = 0
        for i in range(len(prot_ids)):
            prot_id = prot_ids[i]
            prot_len = prot_lens[i]
            df_nsp.loc[df_nsp[id_col_name]==prot_id, FINAL_FEATURE_COLUMNS[7:9]] = prot_len        
        return df_nsp
    
    print('Parsing netsurfp output file ...')
    df_nsp = pd.read_csv(NETSURP_OUTPUT_FILE, sep=',', header=(0), usecols=NETSURFP_COLUMNS)
    df_nsp.columns = FINAL_FEATURE_COLUMNS[0:7]
    id_col_name = FINAL_FEATURE_COLUMNS[0]
    df_lens = df_nsp.groupby(id_col_name)[id_col_name].count()
    prot_ids = df_lens.index.values
    prot_lens = df_lens.values
    df_nsp = addNewCols(df_nsp, id_col_name, prot_ids, prot_lens)
    df_nsp = normalizeData(df_nsp)
    print('Num-nsp_rows: ', len(df_nsp.index))
    
    #print(df_nsp.head())
    #print(df_nsp.iloc[0:2])
    #print(df_nsp.iloc[250])
    return df_nsp

def parseMmseqsPSSMs():
    """
    An example of PSSM file generated by MMSEQS:
    
    Query profile of sequence 0 (for the first protein)
    Pos    Cns    A    C    D    E    F    G    H    I    K    L    M    N    P    Q    R    S    T    V    W    Y
    0    A    8    0    -2    -4    -1    0    -2    -1    -2    0    -1    -2    -2    -2    -2    0    -3    -2    -2    -2
    1    T    0    0    -3    -3    -1    -4    -3    -2    -3    -4    -4    -8    -2    -11    -6    2    6    0    -1    -5
    2    Y    -2    -4    -3    -4    3    -1    2    -1    -2    -8    -1    -2    -1    -6    -1    0    -2    -5    -1    9
    Query profile of sequence 1 (for the second protein)
    Pos    Cns    A    C    D    E    F    G    H    I    K    L    M    N    P    Q    R    S    T    V    W    Y
    0    A    8    0    -2    -4    -1    0    -2    -1    -2    0    -1    -2    -2    -2    -2    0    -3    -2    -2    -2
    1    T    0    0    -3    -3    -1    -4    -3    -2    -3    -4    -4    -8    -2    -11    -6    2    6    0    -1    -5
    2    Y    -2    -4    -3    -4    3    -1    2    -1    -2    -8    -1    -2    -1    -6    -1    0    -2    -5    -1    9
    """
    def normalizePSSM(x):
        # Note that x contains all values for a column; so it's a pandas series.
        y = np.array(x.values.astype(np.int))
        y = 1 / (1+np.exp(-y))
        y = np.around(y, decimals=6)
        #print('new-value: ', y)
        return y
    
    print('Normalizing mmseqs pssm output file ...')
    # Remove the first row (Query profile of sequence 0)
    df_pssm = pd.read_csv(MMSEQS_OUTPUT_FILE, sep='\t', header=(1))
    
    # Selects rows that starts with a number (position number). The reason for this selection is that a PSSM file can contain PSSMS
    # for more than one protein; and the PSSMs for the second protein starts with "Query profile ..." and "Pos    Cns    A ..." again. 
    df_pssm = df_pssm[df_pssm[MMSEQS_PSSM_COLUMNS[0]].astype(str).str.isnumeric()]
    
    # Remove the first two columns (POS and AA). The Netsurfp file already contains AAs and order of AA's remains the same between
    # the Netsurfp file and PSSM file. 
    df_pssm = df_pssm.drop(columns=MMSEQS_PSSM_COLUMNS[0:2])
    
    # Change the names of columns to the original pipenn column names (A-->pssm_A).
    df_pssm.columns = FINAL_FEATURE_COLUMNS[14:]
    
    # Normalize the PSSM values of all AA's of all proteins. 
    df_pssm = df_pssm.apply(normalizePSSM)
    
    # Intermediary results for debug purposes.
    #df_pssm.to_csv(TEMP_FILE, float_format='%.6f', index=False)
    
    print('Num-pssm_rows: ', len(df_pssm.index))
    #print(df_pssm.head())
    return df_pssm
 
def calcWinMean(df_inp):
    wm_cols = FINAL_FEATURE_COLUMNS[2:7] + FINAL_FEATURE_COLUMNS[14:]
    id_col_name = FINAL_FEATURE_COLUMNS[0]
    prot_ids = df_inp[id_col_name].unique() #ALL proteins available
    start_inds = [df_inp.index[df_inp[id_col_name] == prot][0] for prot in prot_ids] #Start index for each protein
    end_inds = [df_inp.index[df_inp[id_col_name] == prot][-1] for prot in prot_ids] #End index for each protein
    
    #Create window means
    df_wm = pd.DataFrame()
    
    #Mean per protein
    for i in [9,7,5,3]:
        #print(i)
        for col in wm_cols:
            temp= []
            for j in range(len(prot_ids)):
                temp.extend(df_inp[start_inds[j]:end_inds[j]+1][col].rolling(window=i, center=True).mean())
            df_wm[str(i) + '_wm_' + str(col)] = temp
            #print(col)
    
    #concatenate the dataframes
    df_inp_wm = pd.concat([df_inp, df_wm], axis=1)
    #print(list(df_inp_wm.columns))
    return df_inp_wm

def genPreparedPipennProtFiles(df_inp_wm):
    DatasetParams.ALL_COLUMNS = DatasetParams.FEATURE_COLUMNS_BIOLIP_WIN
    DatasetParams.LABEL_COL_NAME = 'any_interface'
    DatasetPreparation.prepareBiolipWinData(DatasetParams.USERDS_FILE, DatasetParams.PREPARED_USERDS_FILE, df_inp_wm)
    #"""
    return
    
def generatePipennInput():
    print('Parsing pipenn input file ...')
    #print(FINAL_FEATURE_COLUMNS[0:7])
    #print(FINAL_FEATURE_COLUMNS[7:14])ls 
    #print(FINAL_FEATURE_COLUMNS[14:])
    df_nsp = parseNetsurfpOutput()
    df_pssm = parseMmseqsPSSMs()
    df_inp = pd.concat([df_nsp.reset_index(drop=True), df_pssm.reset_index(drop=True)], axis=1)
    #df_inp.fillna(DatasetParams.MISSING_VALUE_CONST, inplace=True)
    #print(df_inp.head())
    df_inp_wm = calcWinMean(df_inp)
    #df_inp_wm.to_csv(DatasetParams.USERDS_FILE, index=False) 
    #print(df_inp_wm.head())
    genPreparedPipennProtFiles(df_inp_wm)
    return

# import GenerateFeatures; GenerateFeatures.parseUserInput()
if __name__ == "__main__":
    nargs = len(sys.argv)
    if nargs == 4:
        NETSURP_OUTPUT_FILE = sys.argv[1]
        MMSEQS_OUTPUT_FILE = sys.argv[2]
        DatasetParams.PREPARED_USERDS_FILE = sys.argv[3]
        #print("#### args: ", NETSURP_OUTPUT_FILE, " | ", MMSEQS_OUTPUT_FILE, " | ", DatasetParams.PREPARED_USERDS_FILE)
    else:
        print("$$$$$$$$ No proper arguments passed - nargs: ", nargs)
        
    #parseUserInput()
    #pd.set_option('display.max_columns', None)
    #pd.set_option('display.max_rows', None)
    generatePipennInput()
    